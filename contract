// SPDX-License-Identifier: MIT
pragma solidity ^0.8.32;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/utils/Context.sol";

/**
 * @title SupremeAmerToken - 20+ Year Sustainable Mining
 * @dev Mining designed to last decades, not years
 * Total Supply: 20,000,000 SA
 */
contract SupremeAmerToken is Context, ERC20, AccessControl {
    // ============================
    // ROLES
    // ============================
    bytes32 public constant MINING_ADMIN_ROLE = keccak256("MINING_ADMIN");
    bytes32 public constant SAFETY_ADMIN_ROLE = keccak256("SAFETY_ADMIN");
    
    // ============================
    // SUSTAINABLE CONFIGURATION FOR 20+ YEARS
    // ============================
    uint256 public constant TOTAL_SUPPLY = 20_000_000 * 10**18;
    
    // REDUCED REWARD: 0.0005 SA/day (92% reduction from original)
    uint256 public constant DAILY_REWARD = 500 * 10**12; // 0.0005 SA
    
    // INCREASED MINING POOL: 50% (10,000,000 SA)
    uint256 public constant VESTED_PERCENT = 25;    // 5,000,000 SA
    uint256 public constant MINING_PERCENT = 50;    // 10,000,000 SA
    uint256 public constant LIQUIDITY_PERCENT = 25; // 5,000,000 SA
    
    // ============================
    // MINING SYSTEM
    // ============================
    struct Miner {
        uint40 lastClaimTime;
        uint40 upgradeExpiry;
        uint32 dailyClaims;
        uint16 lastClaimDate;
        uint104 totalClaimed;
        uint8 miningTier;
        bool isActive;
    }
    
    mapping(address => Miner) public miners;
    uint32 public totalMiners;
    uint256 public totalDistributed;
    
    // REDUCED MULTIPLIERS
    uint16 public constant TIER1_MULT = 100;  // 1x
    uint16 public constant TIER2_MULT = 130;  // 1.3x
    uint16 public constant TIER3_MULT = 175;  // 1.75x
    
    // INCREASED UPGRADE COSTS (filter serious users)
    uint256 public constant PREMIUM_COST = 2000 * 10**18; // 2,000 SA
    uint256 public constant ULTRA_COST = 8000 * 10**18;   // 8,000 SA
    uint32 public constant UPGRADE_DURATION = 180 days;   // 6 months
    
    // LIMITS
    uint256 public constant MAX_CLAIM = 100_000 * 10**18; // 100,000 SA lifetime
    uint256 public constant CLAIM_INTERVAL = 4 hours;     // Reduced frequency
    uint8 public constant MAX_DAILY_CLAIMS = 6;          // 6 claims/day max
    
    // ============================
    // WALLETS
    // ============================
    address public immutable VESTED_WALLET;
    address public immutable MINING_WALLET;
    address public immutable LIQUIDITY_WALLET;
    
    // ============================
    // STATE
    // ============================
    bool public miningEnabled = true;
    bool public transfersEnabled = true;
    mapping(address => bool) public blacklist;
    uint256 public totalVestedReleased;
    uint40 public immutable VESTING_START;
    uint32 public vestingDuration = 730 days;   // 2-year vesting
    uint32 public vestingCliff = 180 days;      // 6-month cliff
    
    // ============================
    // EVENTS
    // ============================
    event TokensMined(address indexed miner, uint256 amount);
    event MiningRegistered(address indexed user);
    event MiningUpgraded(address indexed user, uint8 fromTier, uint8 toTier);
    
    // ============================
    // MODIFIERS
    // ============================
    modifier onlyMiningAdmin() {
        require(hasRole(MINING_ADMIN_ROLE, _msgSender()), "!admin");
        _;
    }
    
    modifier onlySafetyAdmin() {
        require(hasRole(SAFETY_ADMIN_ROLE, _msgSender()), "!admin");
        _;
    }
    
    modifier notBlacklisted(address a) {
        require(!blacklist[a], "!blacklist");
        _;
    }
    
    modifier miningOn() {
        require(miningEnabled, "!mining");
        _;
    }
    
    // ============================
    // CONSTRUCTOR
    // ============================
    constructor(
        address vested,
        address mining,
        address liquidity
    ) ERC20("SupremeAmer", "SA") {
        require(vested != address(0), "!vested");
        require(mining != address(0), "!mining");
        require(liquidity != address(0), "!liquidity");
        
        VESTED_WALLET = vested;
        MINING_WALLET = mining;
        LIQUIDITY_WALLET = liquidity;
        
        uint256 VESTED_AMOUNT = (TOTAL_SUPPLY * VESTED_PERCENT) / 100;
        uint256 MINING_AMOUNT = (TOTAL_SUPPLY * MINING_PERCENT) / 100;
        uint256 LIQUIDITY_AMOUNT = (TOTAL_SUPPLY * LIQUIDITY_PERCENT) / 100;
        
        VESTING_START = uint40(block.timestamp);
        
        _mint(vested, VESTED_AMOUNT);       // 25% - 5,000,000 SA
        _mint(mining, MINING_AMOUNT);       // 50% - 10,000,000 SA
        _mint(liquidity, LIQUIDITY_AMOUNT); // 25% - 5,000,000 SA
        
        _grantRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _grantRole(MINING_ADMIN_ROLE, _msgSender());
        _grantRole(SAFETY_ADMIN_ROLE, _msgSender());
    }
    
    // ============================
    // REQUIRED OVERRIDES (FIXES THE ABSTRACT WARNING)
    // ============================
    
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) 
        public 
        view 
        virtual 
        override(ERC20, AccessControl) 
        returns (bool) 
    {
        return super.supportsInterface(interfaceId);
    }
    
    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        super._beforeTokenTransfer(from, to, amount);
        
        // Custom logic: prevent blacklisted addresses from sending/receiving
        if (from != address(0)) { // not minting
            require(!blacklist[from], "SupremeAmerToken: sender blacklisted");
        }
        if (to != address(0)) { // not burning
            require(!blacklist[to], "SupremeAmerToken: recipient blacklisted");
        }
        
        // Additional custom logic can be added here
    }
    
    /**
     * @dev Hook that is called after any transfer of tokens. This includes
     * minting and burning.
     */
    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        super._afterTokenTransfer(from, to, amount);
        
        // You can add post-transfer logic here if needed
    }
    
    /**
     * @dev Override _spendAllowance to add custom logic
     */
    function _spendAllowance(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual override {
        require(transfersEnabled, "SupremeAmerToken: transfers disabled");
        super._spendAllowance(owner, spender, amount);
    }
    
    // ============================
    // MINING FUNCTIONS
    // ============================
    function registerMining() external miningOn notBlacklisted(_msgSender()) {
        require(!miners[_msgSender()].isActive, "!active");
        require(balanceOf(_msgSender()) >= 10 * 10**18, "!balance"); // Need 10 SA
        
        miners[_msgSender()] = Miner({
            lastClaimTime: uint40(block.timestamp),
            upgradeExpiry: 0,
            dailyClaims: 0,
            lastClaimDate: 0,
            totalClaimed: 0,
            miningTier: 1,
            isActive: true
        });
        
        totalMiners++;
        emit MiningRegistered(_msgSender());
    }
    
    function claimRewards() external notBlacklisted(_msgSender()) returns (uint256) {
        require(miningEnabled, "!mining");
        Miner storage m = miners[_msgSender()];
        require(m.isActive, "!active");
        require(m.totalClaimed < MAX_CLAIM, "!max");
        
        require(block.timestamp >= m.lastClaimTime + CLAIM_INTERVAL, "!interval");
        
        uint16 today = uint16(block.timestamp / 1 days);
        if (m.lastClaimDate != today) {
            m.lastClaimDate = today;
            m.dailyClaims = 0;
        }
        require(m.dailyClaims < MAX_DAILY_CLAIMS, "!daily");
        
        uint256 timePassed = block.timestamp - m.lastClaimTime;
        require(timePassed > 0, "!time");
        
        uint256 multiplier = _getMultiplier(m.miningTier, m.upgradeExpiry);
        uint256 dailyReward = (DAILY_REWARD * multiplier) / 100;
        uint256 reward = (dailyReward * timePassed) / 86400; // SECONDS_PER_DAY
        
        uint256 poolBalance = balanceOf(MINING_WALLET);
        if (reward > poolBalance) reward = poolBalance;
        
        uint256 remaining = MAX_CLAIM - m.totalClaimed;
        if (reward > remaining) reward = remaining;
        
        require(reward > 0, "!reward");
        
        _transfer(MINING_WALLET, _msgSender(), reward);
        totalDistributed += reward;
        
        m.totalClaimed = uint104(m.totalClaimed + reward);
        m.lastClaimTime = uint40(block.timestamp);
        m.dailyClaims++;
        
        if (m.upgradeExpiry > 0 && block.timestamp > m.upgradeExpiry) {
            m.miningTier = 1;
            m.upgradeExpiry = 0;
        }
        
        emit TokensMined(_msgSender(), reward);
        return reward;
    }
    
    function upgradeMining(uint8 newTier) external notBlacklisted(_msgSender()) {
        require(newTier == 2 || newTier == 3, "!tier");
        require(miningEnabled, "!mining");
        
        Miner storage m = miners[_msgSender()];
        require(m.isActive, "!active");
        require(m.miningTier < newTier, "!upgrade");
        
        uint256 cost = newTier == 2 ? PREMIUM_COST : ULTRA_COST;
        require(balanceOf(_msgSender()) >= cost, "!balance");
        
        _transfer(_msgSender(), MINING_WALLET, cost);
        
        uint8 oldTier = m.miningTier;
        m.miningTier = newTier;
        m.upgradeExpiry = uint40(block.timestamp + UPGRADE_DURATION);
        
        emit MiningUpgraded(_msgSender(), oldTier, newTier);
    }
    
    function _getMultiplier(uint8 tier, uint40 expiry) internal view returns (uint256) {
        if (expiry > 0 && block.timestamp > expiry) return TIER1_MULT;
        if (tier == 3) return TIER3_MULT;
        if (tier == 2) return TIER2_MULT;
        return TIER1_MULT;
    }
    
    function pendingRewards(address user) public view returns (uint256) {
        if (!miners[user].isActive) return 0;
        Miner storage m = miners[user];
        if (m.lastClaimTime == 0) return 0;
        
        uint256 timePassed = block.timestamp - m.lastClaimTime;
        if (timePassed == 0 || timePassed < CLAIM_INTERVAL) return 0;
        
        uint256 multiplier = _getMultiplier(m.miningTier, m.upgradeExpiry);
        uint256 dailyReward = (DAILY_REWARD * multiplier) / 100;
        uint256 reward = (dailyReward * timePassed) / 86400;
        
        uint256 poolBalance = balanceOf(MINING_WALLET);
        uint256 remaining = MAX_CLAIM - m.totalClaimed;
        
        if (reward > poolBalance) reward = poolBalance;
        if (reward > remaining) reward = remaining;
        
        return reward;
    }
    
    // ============================
    // VIEW FUNCTIONS
    // ============================
    function getMinerInfo(address user) external view returns (
        bool isActive,
        uint8 tier,
        uint256 lastClaim,
        uint256 total,
        uint256 pending
    ) {
        Miner storage m = miners[user];
        return (
            m.isActive,
            m.miningTier,
            m.lastClaimTime,
            m.totalClaimed,
            pendingRewards(user)
        );
    }
    
    function getStats() external view returns (
        uint256 miningPool,
        uint256 vestedPool,
        uint256 minersCount,
        uint256 distributed,
        uint256 daysRemaining
    ) {
        uint256 dailyDrain = _estimateDailyDrain();
        uint256 pool = balanceOf(MINING_WALLET);
        uint256 daysLeft = dailyDrain > 0 ? pool / dailyDrain : type(uint256).max;
        
        return (
            pool,
            balanceOf(VESTED_WALLET),
            totalMiners,
            totalDistributed,
            daysLeft
        );
    }
    
    function _estimateDailyDrain() internal view returns (uint256) {
        if (totalMiners == 0) return 0;
        
        // Estimate: 70% Basic, 20% Premium, 10% Ultra
        uint256 avgMultiplier = (TIER1_MULT * 70 + TIER2_MULT * 20 + TIER3_MULT * 10) / 100;
        uint256 avgDailyPerMiner = (DAILY_REWARD * avgMultiplier) / 100;
        
        return avgDailyPerMiner * totalMiners;
    }
    
    // ============================
    // ADMIN FUNCTIONS
    // ============================
    function refillPool(uint256 amount) external onlyMiningAdmin {
        require(amount > 0, "!amount");
        require(balanceOf(_msgSender()) >= amount, "!balance");
        _transfer(_msgSender(), MINING_WALLET, amount);
    }
    
    function setMining(bool enabled) external onlySafetyAdmin {
        miningEnabled = enabled;
    }
    
    function setTransfers(bool enabled) external onlySafetyAdmin {
        transfersEnabled = enabled;
    }
    
    function setBlacklist(address account, bool blacklisted) external onlySafetyAdmin {
        blacklist[account] = blacklisted;
        if (blacklisted && miners[account].isActive) {
            miners[account].isActive = false;
            if (totalMiners > 0) totalMiners--;
        }
    }
    
    // ============================
    // ERC20 OVERRIDES WITH COMPLETE IMPLEMENTATION
    // ============================
    
    /**
     * @dev See {IERC20-transfer}.
     */
    function transfer(address to, uint256 amount) public virtual override returns (bool) {
        require(transfersEnabled, "SupremeAmerToken: transfers disabled");
        address owner = _msgSender();
        require(!blacklist[owner], "SupremeAmerToken: sender blacklisted");
        require(!blacklist[to], "SupremeAmerToken: recipient blacklisted");
        require(amount > 0, "SupremeAmerToken: zero amount");
        
        _transfer(owner, to, amount);
        return true;
    }
    
    /**
     * @dev See {IERC20-transferFrom}.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual override returns (bool) {
        require(transfersEnabled, "SupremeAmerToken: transfers disabled");
        require(!blacklist[from], "SupremeAmerToken: sender blacklisted");
        require(!blacklist[to], "SupremeAmerToken: recipient blacklisted");
        require(amount > 0, "SupremeAmerToken: zero amount");
        
        address spender = _msgSender();
        _spendAllowance(from, spender, amount);
        _transfer(from, to, amount);
        return true;
    }
    
    /**
     * @dev See {IERC20-approve}.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        require(transfersEnabled, "SupremeAmerToken: transfers disabled");
        address owner = _msgSender();
        require(!blacklist[owner], "SupremeAmerToken: owner blacklisted");
        require(!blacklist[spender], "SupremeAmerToken: spender blacklisted");
        
        _approve(owner, spender, amount);
        return true;
    }
    
    /**
     * @dev See {IERC20-increaseAllowance}.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual override returns (bool) {
        require(transfersEnabled, "SupremeAmerToken: transfers disabled");
        address owner = _msgSender();
        require(!blacklist[owner], "SupremeAmerToken: owner blacklisted");
        require(!blacklist[spender], "SupremeAmerToken: spender blacklisted");
        
        _approve(owner, spender, allowance(owner, spender) + addedValue);
        return true;
    }
    
    /**
     * @dev See {IERC20-decreaseAllowance}.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual override returns (bool) {
        require(transfersEnabled, "SupremeAmerToken: transfers disabled");
        address owner = _msgSender();
        require(!blacklist[owner], "SupremeAmerToken: owner blacklisted");
        require(!blacklist[spender], "SupremeAmerToken: spender blacklisted");
        
        uint256 currentAllowance = allowance(owner, spender);
        require(currentAllowance >= subtractedValue, "SupremeAmerToken: decreased allowance below zero");
        unchecked {
            _approve(owner, spender, currentAllowance - subtractedValue);
        }
        
        return true;
    }
    
    // ============================
    // ADDITIONAL FUNCTIONS
    // ============================
    
    /**
     * @dev Returns the name of the token.
     */
    function name() public view virtual override returns (string memory) {
        return "SupremeAmer";
    }
    
    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() public view virtual override returns (string memory) {
        return "SA";
    }
    
    /**
     * @dev Returns the decimals of the token.
     */
    function decimals() public view virtual override returns (uint8) {
        return 18;
    }
    
    // ============================
    // FALLBACK
    // ============================
    receive() external payable {
        revert("SupremeAmerToken: does not accept ETH");
    }
    
    fallback() external payable {
        revert("SupremeAmerToken: invalid call");
    }
}

/**
 * @title 20+ YEAR SUSTAINABLE MINING
 * 
 * âœ… DESIGNED FOR 500K-1M USERS
 * âœ… MINING POOL: 50% (10,000,000 SA)
 * âœ… DAILY REWARD: 0.0005 SA (92% reduced)
 * âœ… LIFETIME: 20+ YEARS
 * 
 * ðŸ“Š SUSTAINABILITY CALCULATION:
 * 
 * Scenario: 1,000,000 users
 * Basic (70%): 700,000 Ã— 0.0005 = 350 SA/day
 * Premium (20%): 200,000 Ã— 0.00065 = 130 SA/day  
 * Ultra (10%): 100,000 Ã— 0.000875 = 87.5 SA/day
 * TOTAL DAILY: 567.5 SA
 * 
 * POOL: 10,000,000 SA Ã· 567.5 SA/day = 17,621 days
 * = 48.3 YEARS âœ…
 * 
 * Even with 2M users: 24+ years
 * Even with ALL users upgrading: 16+ years
 */