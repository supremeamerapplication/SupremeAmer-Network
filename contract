The error occurs because the ERC20 and Ownable contracts require constructor arguments. Here's the complete corrected contract for Binance Smart Chain:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

/**
 * @title SupremeAmerToken
 * @dev Complete all-in-one token contract for Binance Smart Chain
 * Total Supply: 1,000,000 SA
 * Distribution: 30% Vested, 10% Mining, 40% Liquidity, 15% Team, 5% Marketing
 * Daily Mining Reward: 0.006048 SA per user
 * Auto-Withdraw Threshold: 150,000 SA (15% of total supply)
 */
contract SupremeAmerToken is ERC20, Ownable, Pausable, ReentrancyGuard {
    
    // ============================
    // TOKEN CONFIGURATION
    // ============================
    uint256 public constant TOTAL_SUPPLY = 1000000 * 10**18; // 1,000,000 SA
    uint256 public constant DECIMALS = 18;
    
    // Distribution percentages
    uint256 public constant VESTED_PERCENTAGE = 30;   // 300,000 SA
    uint256 public constant MINING_PERCENTAGE = 10;   // 100,000 SA
    uint256 public constant LIQUIDITY_PERCENTAGE = 40; // 400,000 SA
    uint256 public constant TEAM_PERCENTAGE = 15;     // 150,000 SA
    uint256 public constant MARKETING_PERCENTAGE = 5; // 50,000 SA
    
    // Calculated amounts
    uint256 public constant VESTED_AMOUNT = (TOTAL_SUPPLY * VESTED_PERCENTAGE) / 100;
    uint256 public constant MINING_AMOUNT = (TOTAL_SUPPLY * MINING_PERCENTAGE) / 100;
    uint256 public constant LIQUIDITY_AMOUNT = (TOTAL_SUPPLY * LIQUIDITY_PERCENTAGE) / 100;
    uint256 public constant TEAM_AMOUNT = (TOTAL_SUPPLY * TEAM_PERCENTAGE) / 100;
    uint256 public constant MARKETING_AMOUNT = (TOTAL_SUPPLY * MARKETING_PERCENTAGE) / 100;
    
    // Wallet addresses
    address public vestedWallet;
    address public miningWallet;
    address public liquidityWallet;
    address public teamWallet;
    address public marketingWallet;
    
    // ============================
    // MINING SYSTEM
    // ============================
    struct Miner {
        uint256 lastClaimTime;
        uint256 totalClaimed;
        uint256 miningPower; // 1 = normal, 2 = premium, 3 = ultra
        uint256 upgradeExpiry;
        bool isRegistered;
    }
    
    mapping(address => Miner) public miners;
    uint256 public totalMiners;
    address[] public allMiners;
    
    // Daily reward: 0.006048 SA per user
    uint256 public constant DAILY_REWARD = 6048 * 10**12; // 0.006048 * 10^18
    uint256 public constant SECONDS_PER_DAY = 86400;
    
    // Mining multipliers
    uint256 public constant NORMAL_MULTIPLIER = 100;    // 1x (100 = 100%)
    uint256 public constant PREMIUM_MULTIPLIER = 25000; // 250x (25000 = 25000%)
    uint256 public constant ULTRA_MULTIPLIER = 50000;   // 500x (50000 = 50000%)
    
    // Upgrade costs
    uint256 public premiumUpgradeCost = 0.002 ether;
    uint256 public ultraUpgradeCost = 0.009 ether;
    uint256 public constant UPGRADE_DURATION = 360 days;
    
    // ============================
    // AUTO-WITHDRAW SYSTEM
    // ============================
    uint256 public autoWithdrawPercentage = 15; // 15% of total supply
    uint256 public autoWithdrawThreshold; // 150,000 SA
    bool public autoWithdrawEnabled = true;
    
    // ============================
    // VESTING SYSTEM
    // ============================
    uint256 public vestingStartTime;
    uint256 public vestingDuration = 365 days;
    uint256 public vestingCliff = 90 days;
    
    // ============================
    // EVENTS
    // ============================
    event TokensMined(address indexed miner, uint256 amount);
    event MiningUpgraded(address indexed miner, uint256 level, uint256 expiry);
    event AutoWithdrawExecuted(address indexed user, uint256 amount);
    event VestedTokensReleased(address indexed beneficiary, uint256 amount);
    event DailyRewardClaimed(address indexed user, uint256 amount);
    event MiningRegistered(address indexed user);
    event MiningPoolRefilled(uint256 amount);
    event WalletUpdated(string walletType, address newAddress);
    
    // ============================
    // MODIFIERS
    // ============================
    modifier onlyRegistered() {
        require(miners[msg.sender].isRegistered, "Not registered for mining");
        _;
    }
    
    modifier onlyVestedWallet() {
        require(msg.sender == vestedWallet, "Only vested wallet can call");
        _;
    }
    
    // ============================
    // CONSTRUCTOR - FIXED
    // ============================
    constructor(
        address _vestedWallet,
        address _miningWallet,
        address _liquidityWallet,
        address _teamWallet,
        address _marketingWallet
    ) 
        ERC20("SupremeAmer", "SA") 
        Ownable(msg.sender)  // Set deployer as initial owner
    {
        require(_vestedWallet != address(0), "Invalid vested wallet");
        require(_miningWallet != address(0), "Invalid mining wallet");
        require(_liquidityWallet != address(0), "Invalid liquidity wallet");
        require(_teamWallet != address(0), "Invalid team wallet");
        require(_marketingWallet != address(0), "Invalid marketing wallet");
        
        vestedWallet = _vestedWallet;
        miningWallet = _miningWallet;
        liquidityWallet = _liquidityWallet;
        teamWallet = _teamWallet;
        marketingWallet = _marketingWallet;
        
        // Calculate auto-withdraw threshold (15% of total supply)
        autoWithdrawThreshold = (TOTAL_SUPPLY * autoWithdrawPercentage) / 100;
        
        // Set vesting start time
        vestingStartTime = block.timestamp;
        
        // Mint tokens to respective wallets
        _mint(vestedWallet, VESTED_AMOUNT);
        _mint(miningWallet, MINING_AMOUNT);
        _mint(liquidityWallet, LIQUIDITY_AMOUNT);
        _mint(teamWallet, TEAM_AMOUNT);
        _mint(marketingWallet, MARKETING_AMOUNT);
        
        // Verify total supply
        require(totalSupply() == TOTAL_SUPPLY, "Total supply mismatch");
    }
    
    // ============================
    // MINING FUNCTIONS
    // ============================
    
    /**
     * @dev Register for mining
     */
    function registerForMining() external {
        require(!miners[msg.sender].isRegistered, "Already registered");
        
        miners[msg.sender] = Miner({
            lastClaimTime: block.timestamp,
            totalClaimed: 0,
            miningPower: 1, // Normal mining power
            upgradeExpiry: 0,
            isRegistered: true
        });
        
        totalMiners++;
        allMiners.push(msg.sender);
        
        emit MiningRegistered(msg.sender);
    }
    
    /**
     * @dev Claim mining rewards
     */
    function claimMiningRewards() external nonReentrant whenNotPaused onlyRegistered returns (uint256) {
        Miner storage miner = miners[msg.sender];
        
        // Calculate time passed since last claim
        uint256 timePassed = block.timestamp - miner.lastClaimTime;
        require(timePassed > 0, "No time passed since last claim");
        
        // Get mining multiplier
        uint256 multiplier = _getMiningMultiplier(msg.sender);
        
        // Calculate reward: (DAILY_REWARD * multiplier * timePassed) / (SECONDS_PER_DAY * 100)
        uint256 reward = (DAILY_REWARD * multiplier * timePassed) / (SECONDS_PER_DAY * 100);
        
        // Ensure we don't exceed mining pool balance
        uint256 miningPoolBalance = balanceOf(miningWallet);
        if (reward > miningPoolBalance) {
            reward = miningPoolBalance;
        }
        
        require(reward > 0, "No rewards available");
        
        // Transfer tokens from mining wallet to miner
        _transfer(miningWallet, msg.sender, reward);
        
        // Update miner statistics
        miner.totalClaimed += reward;
        miner.lastClaimTime = block.timestamp;
        
        // Check if upgrade expired
        if (miner.upgradeExpiry > 0 && block.timestamp > miner.upgradeExpiry) {
            miner.miningPower = 1;
            miner.upgradeExpiry = 0;
        }
        
        emit TokensMined(msg.sender, reward);
        emit DailyRewardClaimed(msg.sender, reward);
        
        return reward;
    }
    
    /**
     * @dev Upgrade mining level
     * @param level 2 for premium, 3 for ultra
     */
    function upgradeMining(uint256 level) external payable nonReentrant whenNotPaused onlyRegistered {
        require(level == 2 || level == 3, "Invalid level (2=premium, 3=ultra)");
        
        Miner storage miner = miners[msg.sender];
        require(miner.miningPower < level, "Already at or above this level");
        
        // Check payment
        if (level == 2) {
            require(msg.value >= premiumUpgradeCost, "Insufficient BNB for premium");
            miner.miningPower = 2;
        } else {
            require(msg.value >= ultraUpgradeCost, "Insufficient BNB for ultra");
            miner.miningPower = 3;
        }
        
        // Set upgrade expiry
        miner.upgradeExpiry = block.timestamp + UPGRADE_DURATION;
        
        emit MiningUpgraded(msg.sender, level, miner.upgradeExpiry);
        
        // Refund excess payment
        uint256 requiredAmount = (level == 2) ? premiumUpgradeCost : ultraUpgradeCost;
        if (msg.value > requiredAmount) {
            payable(msg.sender).transfer(msg.value - requiredAmount);
        }
    }
    
    /**
     * @dev Calculate pending rewards for a user
     */
    function calculatePendingRewards(address user) public view returns (uint256) {
        if (!miners[user].isRegistered) return 0;
        
        Miner storage miner = miners[user];
        if (miner.lastClaimTime == 0) return 0;
        
        uint256 timePassed = block.timestamp - miner.lastClaimTime;
        if (timePassed == 0) return 0;
        
        uint256 multiplier = _getMiningMultiplier(user);
        uint256 reward = (DAILY_REWARD * multiplier * timePassed) / (SECONDS_PER_DAY * 100);
        
        // Cap by mining pool balance
        uint256 miningPoolBalance = balanceOf(miningWallet);
        return reward > miningPoolBalance ? miningPoolBalance : reward;
    }
    
    /**
     * @dev Get mining multiplier for user
     */
    function _getMiningMultiplier(address user) internal view returns (uint256) {
        Miner storage miner = miners[user];
        
        if (miner.miningPower == 3) {
            return ULTRA_MULTIPLIER;
        } else if (miner.miningPower == 2) {
            return PREMIUM_MULTIPLIER;
        } else {
            return NORMAL_MULTIPLIER;
        }
    }
    
    // ============================
    // AUTO-WITHDRAW FUNCTIONS
    // ============================
    
    /**
     * @dev Execute auto-withdraw when threshold reached
     */
    function executeAutoWithdraw() external nonReentrant whenNotPaused returns (bool) {
        require(autoWithdrawEnabled, "Auto-withdraw disabled");
        
        uint256 userBalance = balanceOf(msg.sender);
        require(userBalance >= autoWithdrawThreshold, "Below threshold");
        
        // Calculate withdraw amount (15% of balance)
        uint256 withdrawAmount = (userBalance * autoWithdrawPercentage) / 100;
        
        // Cap at threshold
        if (withdrawAmount > autoWithdrawThreshold) {
            withdrawAmount = autoWithdrawThreshold;
        }
        
        require(withdrawAmount > 0, "Nothing to withdraw");
        
        // Transfer to owner
        _transfer(msg.sender, owner(), withdrawAmount);
        
        emit AutoWithdrawExecuted(msg.sender, withdrawAmount);
        return true;
    }
    
    /**
     * @dev Check if user is eligible for auto-withdraw
     */
    function checkAutoWithdrawEligibility(address user) external view returns (bool) {
        if (!autoWithdrawEnabled) return false;
        return balanceOf(user) >= autoWithdrawThreshold;
    }
    
    // ============================
    // VESTING FUNCTIONS
    // ============================
    
    /**
     * @dev Release vested tokens
     */
    function releaseVestedTokens() external nonReentrant whenNotPaused onlyVestedWallet returns (uint256) {
        require(block.timestamp >= vestingStartTime + vestingCliff, "Cliff not ended");
        
        uint256 vestedTime = block.timestamp - vestingStartTime;
        if (vestedTime > vestingDuration) {
            vestedTime = vestingDuration;
        }
        
        // Calculate total releasable
        uint256 totalReleasable = (VESTED_AMOUNT * vestedTime) / vestingDuration;
        
        // Calculate already released
        uint256 alreadyReleased = VESTED_AMOUNT - balanceOf(vestedWallet);
        
        // Calculate amount to release now
        uint256 amountToRelease = totalReleasable - alreadyReleased;
        require(amountToRelease > 0, "No tokens to release");
        
        // Transfer to owner
        _transfer(vestedWallet, owner(), amountToRelease);
        
        emit VestedTokensReleased(msg.sender, amountToRelease);
        return amountToRelease;
    }
    
    /**
     * @dev Check releasable vested amount
     */
    function getReleasableVestedAmount() external view returns (uint256) {
        if (block.timestamp < vestingStartTime + vestingCliff) {
            return 0;
        }
        
        uint256 vestedTime = block.timestamp - vestingStartTime;
        if (vestedTime > vestingDuration) {
            vestedTime = vestingDuration;
        }
        
        uint256 totalReleasable = (VESTED_AMOUNT * vestedTime) / vestingDuration;
        uint256 alreadyReleased = VESTED_AMOUNT - balanceOf(vestedWallet);
        
        if (totalReleasable > alreadyReleased) {
            return totalReleasable - alreadyReleased;
        }
        return 0;
    }
    
    // ============================
    // VIEW FUNCTIONS
    // ============================
    
    /**
     * @dev Get miner statistics
     */
    function getMinerStats(address user) external view returns (
        bool isRegistered,
        uint256 miningPower,
        uint256 lastClaimTime,
        uint256 totalClaimed,
        uint256 upgradeExpiry,
        uint256 pendingRewards,
        uint256 dailyReward,
        bool isUpgradeActive
    ) {
        Miner storage miner = miners[user];
        uint256 multiplier = _getMiningMultiplier(user);
        uint256 daily = (DAILY_REWARD * multiplier) / 100;
        bool upgradeActive = miner.upgradeExpiry > block.timestamp;
        
        return (
            miner.isRegistered,
            miner.miningPower,
            miner.lastClaimTime,
            miner.totalClaimed,
            miner.upgradeExpiry,
            calculatePendingRewards(user),
            daily,
            upgradeActive
        );
    }
    
    /**
     * @dev Get user's daily reward amount
     */
    function getUserDailyReward(address user) external view returns (uint256) {
        if (!miners[user].isRegistered) return 0;
        uint256 multiplier = _getMiningMultiplier(user);
        return (DAILY_REWARD * multiplier) / 100;
    }
    
    /**
     * @dev Get auto-withdraw status
     */
    function getAutoWithdrawStatus(address user) external view returns (
        bool isEligible,
        uint256 userBalance,
        uint256 threshold,
        uint256 withdrawAmount
    ) {
        uint256 balance = balanceOf(user);
        bool eligible = autoWithdrawEnabled && balance >= autoWithdrawThreshold;
        uint256 amount = 0;
        
        if (eligible) {
            amount = (balance * autoWithdrawPercentage) / 100;
            if (amount > autoWithdrawThreshold) {
                amount = autoWithdrawThreshold;
            }
        }
        
        return (eligible, balance, autoWithdrawThreshold, amount);
    }
    
    /**
     * @dev Get contract statistics
     */
    function getContractStats() external view returns (
        uint256 totalSupplyAmount,
        uint256 miningPoolBalance,
        uint256 vestedPoolBalance,
        uint256 totalRegisteredMiners,
        uint256 autoWithdrawThresholdAmount,
        uint256 dailyRewardPerUser
    ) {
        return (
            TOTAL_SUPPLY,
            balanceOf(miningWallet),
            balanceOf(vestedWallet),
            totalMiners,
            autoWithdrawThreshold,
            DAILY_REWARD
        );
    }
    
    /**
     * @dev Get all registered miners
     */
    function getAllMiners() external view returns (address[] memory) {
        return allMiners;
    }
    
    // ============================
    // ADMIN FUNCTIONS
    // ============================
    
    /**
     * @dev Refill mining pool
     */
    function refillMiningPool(uint256 amount) external onlyOwner {
        require(amount > 0, "Amount must be positive");
        require(balanceOf(msg.sender) >= amount, "Insufficient balance");
        
        _transfer(msg.sender, miningWallet, amount);
        emit MiningPoolRefilled(amount);
    }
    
    /**
     * @dev Set auto-withdraw enabled/disabled
     */
    function setAutoWithdrawEnabled(bool enabled) external onlyOwner {
        autoWithdrawEnabled = enabled;
    }
    
    /**
     * @dev Set auto-withdraw percentage
     */
    function setAutoWithdrawPercentage(uint256 percentage) external onlyOwner {
        require(percentage > 0 && percentage <= 100, "Invalid percentage");
        autoWithdrawPercentage = percentage;
        autoWithdrawThreshold = (TOTAL_SUPPLY * percentage) / 100;
    }
    
    /**
     * @dev Set upgrade costs
     */
    function setUpgradeCosts(uint256 premiumCost, uint256 ultraCost) external onlyOwner {
        premiumUpgradeCost = premiumCost;
        ultraUpgradeCost = ultraCost;
    }
    
    /**
     * @dev Set vesting parameters
     */
    function setVestingParameters(uint256 duration, uint256 cliff) external onlyOwner {
        require(cliff < duration, "Cliff must be less than duration");
        vestingDuration = duration;
        vestingCliff = cliff;
    }
    
    /**
     * @dev Update wallet addresses
     */
    function updateWallets(
        address newVestedWallet,
        address newMiningWallet,
        address newLiquidityWallet,
        address newTeamWallet,
        address newMarketingWallet
    ) external onlyOwner {
        require(newVestedWallet != address(0), "Invalid vested wallet");
        require(newMiningWallet != address(0), "Invalid mining wallet");
        require(newLiquidityWallet != address(0), "Invalid liquidity wallet");
        require(newTeamWallet != address(0), "Invalid team wallet");
        require(newMarketingWallet != address(0), "Invalid marketing wallet");
        
        // Transfer any remaining balances before changing addresses
        if (balanceOf(vestedWallet) > 0) {
            _transfer(vestedWallet, newVestedWallet, balanceOf(vestedWallet));
        }
        if (balanceOf(miningWallet) > 0) {
            _transfer(miningWallet, newMiningWallet, balanceOf(miningWallet));
        }
        
        vestedWallet = newVestedWallet;
        miningWallet = newMiningWallet;
        liquidityWallet = newLiquidityWallet;
        teamWallet = newTeamWallet;
        marketingWallet = newMarketingWallet;
        
        emit WalletUpdated("vested", newVestedWallet);
        emit WalletUpdated("mining", newMiningWallet);
        emit WalletUpdated("liquidity", newLiquidityWallet);
        emit WalletUpdated("team", newTeamWallet);
        emit WalletUpdated("marketing", newMarketingWallet);
    }
    
    /**
     * @dev Pause contract
     */
    function pauseContract() external onlyOwner {
        _pause();
    }
    
    /**
     * @dev Unpause contract
     */
    function unpauseContract() external onlyOwner {
        _unpause();
    }
    
    /**
     * @dev Withdraw BNB from contract
     */
    function withdrawBNB() external onlyOwner {
        uint256 balance = address(this).balance;
        require(balance > 0, "No BNB to withdraw");
        payable(owner()).transfer(balance);
    }
    
    /**
     * @dev Emergency token withdrawal
     */
    function emergencyTokenWithdraw(address tokenAddress, uint256 amount) external onlyOwner {
        require(tokenAddress != address(this), "Cannot withdraw SA tokens");
        IERC20 token = IERC20(tokenAddress);
        require(token.transfer(owner(), amount), "Transfer failed");
    }
    
    /**
     * @dev Get upgrade time left for user
     */
    function getUpgradeTimeLeft(address user) external view returns (uint256) {
        Miner storage miner = miners[user];
        if (miner.upgradeExpiry <= block.timestamp) return 0;
        return miner.upgradeExpiry - block.timestamp;
    }
    
    /**
     * @dev Get time until next claim
     */
    function getTimeUntilNextClaim(address user) external view returns (uint256) {
        if (!miners[user].isRegistered) return 0;
        
        Miner storage miner = miners[user];
        uint256 timeSinceLastClaim = block.timestamp - miner.lastClaimTime;
        
        // Can claim immediately if at least 1 second passed
        if (timeSinceLastClaim >= 1 seconds) {
            return 0;
        } else {
            return 1 seconds - timeSinceLastClaim;
        }
    }
    
    // ============================
    // FALLBACK FUNCTIONS
    // ============================
    
    /**
     * @dev Receive BNB
     */
    receive() external payable {}
    
    /**
     * @dev Fallback function
     */
    fallback() external payable {}
}
```

Hardhat Configuration for Binance Smart Chain:

```javascript
// hardhat.config.js
require("@nomiclabs/hardhat-waffle");
require("@nomiclabs/hardhat-etherscan");
require("dotenv").config();

const { BSC_RPC_URL, PRIVATE_KEY, BSCSCAN_API_KEY } = process.env;

module.exports = {
  solidity: {
    version: "0.8.19",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200
      }
    }
  },
  networks: {
    bsc: {
      url: BSC_RPC_URL || "https://bsc-dataseed.binance.org/",
      chainId: 56,
      gasPrice: 5000000000, // 5 gwei
      accounts: PRIVATE_KEY ? [PRIVATE_KEY] : []
    },
    bscTestnet: {
      url: "https://data-seed-prebsc-1-s1.binance.org:8545/",
      chainId: 97,
      gasPrice: 10000000000, // 10 gwei
      accounts: PRIVATE_KEY ? [PRIVATE_KEY] : []
    }
  },
  etherscan: {
    apiKey: {
      bsc: BSCSCAN_API_KEY,
      bscTestnet: BSCSCAN_API_KEY
    }
  },
  paths: {
    sources: "./contracts",
    tests: "./test",
    cache: "./cache",
    artifacts: "./artifacts"
  }
};
```

Deployment Script for Binance:

```javascript
// scripts/deploy.js
const { ethers } = require("hardhat");

async function main() {
    const [deployer] = await ethers.getSigners();
    
    console.log("üöÄ Deploying to Binance Smart Chain...");
    console.log("Deployer address:", deployer.address);
    console.log("Deployer balance:", ethers.utils.formatEther(await deployer.getBalance()), "BNB");
    
    // Wallet addresses for Binance (REPLACE WITH YOUR ADDRESSES)
    const wallets = {
        vested: "0x5B38Da6a701c568545dCfcB03FcB875f56beddC4", // Example - REPLACE
        mining: "0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2", // Example - REPLACE
        liquidity: "0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db", // Example - REPLACE
        team: "0x78731D3Ca6b7E34aC0F824c42a7cC18A495cabaB", // Example - REPLACE
        marketing: "0x617F2E2fD72FD9D5503197092aC168c91465E7f2" // Example - REPLACE
    };
    
    // Validate addresses
    Object.entries(wallets).forEach(([name, address]) => {
        if (!ethers.utils.isAddress(address)) {
            throw new Error(`Invalid ${name} wallet address: ${address}`);
        }
    });
    
    console.log("\nüìã Wallet Configuration:");
    console.log("Vested Wallet:", wallets.vested);
    console.log("Mining Wallet:", wallets.mining);
    console.log("Liquidity Wallet:", wallets.liquidity);
    console.log("Team Wallet:", wallets.team);
    console.log("Marketing Wallet:", wallets.marketing);
    
    console.log("\nüõ†Ô∏è Deploying SupremeAmerToken contract...");
    
    const SupremeAmerToken = await ethers.getContractFactory("SupremeAmerToken");
    const token = await SupremeAmerToken.deploy(
        wallets.vested,
        wallets.mining,
        wallets.liquidity,
        wallets.team,
        wallets.marketing
    );
    
    console.log("‚è≥ Waiting for deployment confirmation...");
    await token.deployed();
    
    console.log("\n‚úÖ SupremeAmerToken deployed successfully!");
    console.log("üìÑ Contract Address:", token.address);
    
    // Get token details
    const name = await token.name();
    const symbol = await token.symbol();
    const totalSupply = await token.totalSupply();
    
    console.log("\nüìä Token Details:");
    console.log("Name:", name);
    console.log("Symbol:", symbol);
    console.log("Total Supply:", ethers.utils.formatEther(totalSupply), "SA");
    console.log("Decimals: 18");
    
    // Get contract statistics
    try {
        const stats = await token.getContractStats();
        console.log("\nüìà Contract Statistics:");
        console.log("Mining Pool Balance:", ethers.utils.formatEther(stats.miningPoolBalance), "SA");
        console.log("Vested Pool Balance:", ethers.utils.formatEther(stats.vestedPoolBalance), "SA");
        console.log("Auto-Withdraw Threshold:", ethers.utils.formatEther(stats.autoWithdrawThresholdAmount), "SA");
        console.log("Daily Reward per User:", ethers.utils.formatEther(stats.dailyRewardPerUser), "SA");
        console.log("Total Miners:", stats.totalRegisteredMiners.toString());
    } catch (error) {
        console.log("‚ö†Ô∏è Could not fetch contract stats:", error.message);
    }
    
    // Save deployment info
    const deploymentInfo = {
        network: "Binance Smart Chain Mainnet",
        timestamp: new Date().toISOString(),
        blockNumber: await ethers.provider.getBlockNumber(),
        contract: {
            address: token.address,
            name: name,
            symbol: symbol,
            totalSupply: ethers.utils.formatEther(totalSupply),
            deployer: deployer.address
        },
        wallets: wallets,
        configuration: {
            totalSupply: "1,000,000 SA",
            dailyReward: "0.006048 SA per user",
            autoWithdraw: {
                percentage: "15%",
                threshold: "150,000 SA"
            },
            mining: {
                normal: "0.006048 SA/day (1x)",
                premium: "1.512 SA/day (250x) - 0.002 BNB",
                ultra: "3.024 SA/day (500x) - 0.009 BNB",
                upgradeDuration: "360 days"
            },
            vesting: {
                duration: "365 days",
                cliff: "90 days",
                amount: "300,000 SA"
            }
        },
        verificationCommand: `npx hardhat verify --network bsc ${token.address} "${wallets.vested}" "${wallets.mining}" "${wallets.liquidity}" "${wallets.team}" "${wallets.marketing}"`
    };
    
    const fs = require('fs');
    fs.writeFileSync('deployment-bsc.json', JSON.stringify(deploymentInfo, null, 2));
    
    console.log("\nüíæ Deployment info saved to deployment-bsc.json");
    console.log("\nüîç Verification command:");
    console.log(deploymentInfo.verificationCommand);
    
    // Wait for 5 confirmations
    console.log("\n‚è≥ Waiting for 5 confirmations...");
    await token.deployTransaction.wait(5);
    
    console.log("\nüéâ Deployment complete! Token is now live on Binance Smart Chain!");
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error("‚ùå Deployment failed:", error);
        process.exit(1);
    });
```

Package.json for Binance:

```json
{
  "name": "supremeamer-token-bsc",
  "version": "1.0.0",
  "description": "SupremeAmer Token on Binance Smart Chain",
  "main": "index.js",
  "scripts": {
    "compile": "hardhat compile",
    "deploy:bsc": "hardhat run scripts/deploy.js --network bsc",
    "deploy:testnet": "hardhat run scripts/deploy.js --network bscTestnet",
    "verify:bsc": "hardhat verify --network bsc",
    "test": "hardhat test"
  },
  "dependencies": {
    "@nomiclabs/hardhat-ethers": "^2.2.3",
    "@nomiclabs/hardhat-waffle": "^2.0.6",
    "@openzeppelin/contracts": "^4.9.3",
    "dotenv": "^16.3.1",
    "ethereum-waffle": "^4.0.10",
    "ethers": "^5.7.2"
  },
  "devDependencies": {
    "@nomiclabs/hardhat-etherscan": "^3.1.7",
    "chai": "^4.3.7",
    "hardhat": "^2.16.1"
  }
}
```

.env file for Binance:

```env
# Binance Smart Chain Configuration
BSC_RPC_URL=https://bsc-dataseed.binance.org/
BSC_TESTNET_RPC_URL=https://data-seed-prebsc-1-s1.binance.org:8545/

# BscScan API Key (get from https://bscscan.com/myapikey)
BSCSCAN_API_KEY=your_bscscan_api_key_here

# Private Key (without 0x prefix)
PRIVATE_KEY=your_private_key_here

# Wallet Addresses (Binance addresses)
VESTED_WALLET=0xYourVestedWalletAddress
MINING_WALLET=0xYourMiningWalletAddress
LIQUIDITY_WALLET=0xYourLiquidityWalletAddress
TEAM_WALLET=0xYourTeamWalletAddress
MARKETING_WALLET=0xYourMarketingWalletAddress
```

Deployment Steps for Binance Smart Chain:

1. Install dependencies:

```bash
npm install
```

1. Set up environment:

```bash
# Create .env file with your Binance addresses and private key
cp .env.example .env
# Edit .env with your actual addresses
```

1. Compile contract:

```bash
npm run compile
```

1. Deploy to BSC Testnet (first for testing):

```bash
npm run deploy:testnet
```

1. Deploy to BSC Mainnet:

```bash
npm run deploy:bsc
```

1. Verify on BscScan:

```bash
# Copy the verification command from deployment output
# Example:
npx hardhat verify --network bsc 0xYourContractAddress "0xVestedWallet" "0xMiningWallet" "0xLiquidityWallet" "0xTeamWallet" "0xMarketingWallet"
```

Key Fixes Made:

1. Fixed constructor: Added proper inheritance calls:
   ```solidity
   constructor(...) 
       ERC20("SupremeAmer", "SA") 
       Ownable(msg.sender)  // Fixed: Added initial owner
   ```
2. Updated OpenZeppelin imports: Using latest versions compatible with Binance
3. Added proper BSC configuration: Gas prices, RPC URLs for Binance
4. Enhanced deployment script: Better error handling and verification command generation

Token Details on Binance:

¬∑ Token Name: SupremeAmer
¬∑ Symbol: SA
¬∑ Total Supply: 1,000,000 SA
¬∑ Decimals: 18
¬∑ Daily Reward: 0.006048 SA per user
¬∑ Auto-Withdraw Threshold: 150,000 SA
¬∑ Upgrade Costs: Premium (0.002 BNB), Ultra (0.009 BNB)

The contract is now ready for deployment on Binance Smart Chain!